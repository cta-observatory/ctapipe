"""Module containing classes related to event loading and preprocessing"""

from enum import StrEnum, auto
from pathlib import Path

import astropy.units as u
import numpy as np
from astropy.coordinates import AltAz, SkyCoord, angular_separation
from astropy.table import QTable, vstack

try:
    from pyirf.simulations import SimulatedEventsInfo
    from pyirf.spectral import (
        DIFFUSE_FLUX_UNIT,
        POINT_SOURCE_FLUX_UNIT,
        PowerLaw,
        calculate_event_weights,
    )
    from pyirf.utils import calculate_source_fov_offset, calculate_theta

    has_pyirf = True
except ModuleNotFoundError:
    has_pyirf = False

from tables import NoSuchNodeError
from traitlets import default

from ..coordinates import NominalFrame, altaz_to_fov
from ..core import Component, FeatureGenerator, QualityQuery
from ..core.traits import CaselessStrEnum, Dict, List, Unicode
from .tableloader import TableLoader

__all__ = [
    "DL2EventLoader",
    "DL2EventPreprocessor",
]


class DL2FeatureSet(StrEnum):
    custom = auto()
    simulation = auto()


class DL2EventPreprocessor(Component):
    """
    Selects or generates features and filters tables of events.

    In normal use, one only has to specify the ``feature_set`` option, which
    will generate features supports standard use cases. For advanced usage, you
    can set ``feature_set=custom`` and pass in a configured
    `~ctapipe.core.FeatureGenerator` and set the ``features`` property of this
    class with the columns you to retain in the output table.

    In the `~ctapipe.core.FeatureGenerator`` used internally, you have access to several
    additional functions useful for DL2 processing:

      - `~astropy.coordinates.angular_separation`
      - `~ctapipe.coordinates.alt_az_to_fov`
    """

    classes = [QualityQuery, FeatureGenerator]

    energy_reconstructor = Unicode(
        default_value="RandomForestRegressor",
        help="Prefix of the reco `_energy` column",
    ).tag(config=True)

    geometry_reconstructor = Unicode(
        default_value="HillasReconstructor",
        help="Prefix of the `_alt` and `_az` reco geometry columns",
    ).tag(config=True)

    gammaness_classifier = Unicode(
        default_value="RandomForestClassifier",
        help="Prefix of the classifier `_prediction` column",
    ).tag(config=True)

    feature_set = CaselessStrEnum(
        values=[str(x) for x in DL2FeatureSet],
        default_value=str(DL2FeatureSet.simulation),
        help=(
            "Set up the FeatureGenerator.features and output features based on standard use cases."
            "Specify 'custom' if you want to set your own in your config file. If this is set to "
            "any value other than 'custom', the feature properties of the configuration "
            "file you pass in will be overridden."
        ),
    )

    features = List(
        Unicode(),
        help=(
            "Features (columns) to retain in the output.  "
            "These can include columns generated by the FeatureGenerator. "
            "If you set these, make sure feature_set=custom."
        ),
    ).tag(config=True)

    def __init__(self, config=None, parent=None, **kwargs):
        super().__init__(config=config, parent=parent, **kwargs)
        if DL2FeatureSet(self.feature_set) == DL2FeatureSet.custom:
            self.feature_generator = FeatureGenerator(parent=self)
            self.quality_query = QualityQuery(parent=self)
        else:
            self.feature_generator = FeatureGenerator(
                features=self._get_predefined_features_to_generate()
            )
            self.quality_query = QualityQuery(
                quality_criteria=self._get_predefined_quality_criteria()
            )

    def __call__(self, table):
        """Return new table with only the columns in features."""

        # generate new features, which includes renaming columns:
        generated = self.feature_generator(
            table, angular_separation=angular_separation, altaz_to_fov=altaz_to_fov
        )

        # apply event selection on the resulting table

        # return only the olumns specified in `self.features`:
        return generated[self.features]

    @default("features")
    def default_features(self):
        """Set the default features to output from the DL2FeatureSet."""
        if self.feature_set == DL2FeatureSet.simulation:
            return [
                "reco_energy",
                "reco_alt",
                "reco_az",
                "gh_score",
                "true_energy",
                "true_alt",
                "true_az",
                "true_fov_offset",
                "reco_fov_offset",
                "theta",
                "reco_fov_lat",
                "true_fov_lat",
                "reco_fov_lon",
                "true_fov_lon",
            ]
        elif self.feature_set == DL2FeatureSet.custom:
            return []
        else:
            raise NotImplementedError(f"unsupported feature_set: {self.feature_set}")

    def _get_predefined_quality_criteria(self) -> list[tuple]:
        """Return QualityQuery configuration for a DL2FeatureSet."""
        if self.feature_set == DL2FeatureSet.simulation:
            return [
                (
                    "multiplicity 4",
                    f"np.count_nonzero({self.geometry_reconstructor}_telescopes,axis=1) >= 4",
                ),
                ("valid classifier", f"{self.gammaness_classifier}_is_valid"),
                ("valid geom reco", f"{self.geometry_reconstructor}_is_valid"),
                ("valid energy reco", f"{self.energy_reconstructor}_is_valid"),
            ]
        else:
            raise NotImplementedError(f"unsupported feature_set: {self.feature_set}")

    def _get_predefined_features_to_generate(self) -> list[tuple]:
        """Return a default list of FeatureGenerator features."""
        if self.feature_set == DL2FeatureSet.simulation:
            # Default features for DL2/Subarray events
            return [
                ("reco_energy", f"{self.energy_reconstructor}_energy"),
                ("reco_alt", f"{self.geometry_reconstructor}_alt"),
                ("reco_az", f"{self.geometry_reconstructor}_az"),
                ("gh_score", f"{self.gammaness_classifier}_prediction"),
                ("theta", "angular_separation(reco_az, reco_alt, true_az, true_alt)"),
                (
                    "reco_fov_coord",
                    "altaz_to_fov(reco_az, reco_alt, subarray_pointing_lon, subarray_pointing_lat)",
                ),
                ("reco_fov_lon", "reco_fov_coord[:,0]"),
                ("reco_fov_lat", "reco_fov_coord[:,1]"),
                (
                    "true_fov_coord",
                    "altaz_to_fov(true_az, true_alt, subarray_pointing_lon, subarray_pointing_lat)",
                ),
                ("true_fov_lon", "true_fov_coord[:,0]"),
                ("true_fov_lat", "true_fov_coord[:,1]"),
                (
                    "true_fov_offset",
                    "angular_separation(reco_fov_lon, reco_fov_lat, 0*u.deg, 0*u.deg)",
                ),
                (
                    "reco_fov_offset",
                    "angular_separation(true_fov_lon, reco_fov_lat, 0*u.deg, 0*u.deg)",
                ),
            ]
        else:
            raise NotImplementedError(f"unsupported feature_set: {self.feature_set}")


class DL2EventLoader(Component):
    """
    Component for loading events and simulation metadata, applying preselection and optional derived column logic.
    """

    classes = [DL2EventPreprocessor]

    # User-selectable event reading function and kwargs
    event_reader_function = Unicode(
        default_value="read_subarray_events_chunked",
        help=(
            "Function of TableLoader used to read event chunks. "
            "E.g., 'read_subarray_events_chunked' or 'read_telescope_events_chunked'."
        ),
    ).tag(config=True)

    event_reader_kwargs = Dict(
        default_value={},
        help="Extra keyword arguments passed to the event reading function, e.g., {'path': '/dl2/event/telescope/Reconstructor'}",
    ).tag(config=True)

    def __init__(self, file: Path, target_spectrum: "Spectra", **kwargs):  # noqa: F821
        from ..irf.spectra import SPECTRA

        super().__init__(**kwargs)
        self.epp = DL2EventPreprocessor(parent=self)
        self.target_spectrum = SPECTRA[target_spectrum]
        self.file = file

    def load_preselected_events(
        self, chunk_size: int, obs_time: u.Quantity
    ) -> tuple[QTable, int, dict]:
        """
        Load and filter events from the file.

        Parameters
        ----------
        chunk_size : int
            Size of chunks to read from the file.
        obs_time : Quantity
            Observation time to scale weights.

        Returns
        -------
        table : QTable
            Filtered and processed event table.
        n_raw_events : int
            Number of events before selection.
        meta : dict
            Metadata dictionary with simulation info and input spectrum.
        """

        opts = dict(dl2=True, simulated=True, observation_info=True)

        with TableLoader(self.file, parent=self, **opts) as loader:
            table_template = self.epp.make_empty_table()
            sim_info, spectrum = self.get_simulation_information(loader, obs_time)
            meta = {"sim_info": sim_info, "spectrum": spectrum}
            event_chunks = [table_template]
            n_raw_events = 0
            reader_func = getattr(loader, self.event_reader_function)
            table_reader = reader_func(chunk_size, **opts, **self.event_reader_kwargs)
            for _, _, events in table_reader:
                selected = events[self.epp.quality_query.get_table_mask(events)]
                selected = self.epp.normalise_column_names(selected)
                if self.epp.apply_derived_columns:
                    selected = self.make_derived_columns(selected)
                event_chunks.append(selected)
                n_raw_events += len(events)

            event_chunks.append(
                table_template
            )  # Putting it last ensures the correct metadata is used
            table = vstack(event_chunks, join_type="exact", metadata_conflicts="silent")
            return table, n_raw_events, meta

    def get_simulation_information(
        self, loader: TableLoader, obs_time: u.Quantity
    ) -> tuple["SimulatedEventsInfo", "PowerLaw"]:
        """
        Extract simulation information from the input file.

        Parameters
        ----------
        loader : TableLoader
            Loader object for reading from the input file.
        obs_time : Quantity
            Total observation time.

        Returns
        -------
        sim_info : SimulatedEventsInfo
            Metadata about the simulated events.
        spectrum : PowerLaw
            Power-law model derived from simulation configuration.

        Raises
        ------
        NotImplementedError
            If simulation parameters vary across runs.
        """
        from ..exceptions import OptionalDependencyMissing

        if not has_pyirf:
            raise OptionalDependencyMissing("pyirf")

        sim_config = loader.read_simulation_configuration()
        n_showers: int = 0
        try:
            shower_distribution = loader.read_shower_distribution()
            n_showers = shower_distribution["n_entries"].sum()
        except NoSuchNodeError:
            self.log.warning(
                "Simulation distributions were not found in the input files, "
                "falling back to estimating the number of showers from the "
                "simulation configuration."
            )

        # Some tight consistency checks. Eventually we will support using the
        # arbitrary shower distribution and non-flat spatial distributions.
        # Currently we do not support those, so we raise exceptions here to
        # avoid that we incorrectly compute the effective area, which would have
        # a high scientific impact.
        for itm in [
            "spectral_index",
            "energy_range_min",
            "energy_range_max",
            "max_scatter_range",
            "max_viewcone_radius",
            "min_viewcone_radius",
        ]:
            if len(np.unique(sim_config[itm])) > 1:
                raise NotImplementedError(
                    f"Unsupported: '{itm}' differs across simulation runs"
                )

        n_showers_config = (sim_config["n_showers"] * sim_config["shower_reuse"]).sum()
        if n_showers == 0:
            n_showers = n_showers_config

        assert n_showers_config == n_showers, "Inconsistent number of simulated showers"

        # This gets the distribution assuming a power-law model, and we assume
        # all merged observations have the same model.
        sim_info = SimulatedEventsInfo(
            n_showers=n_showers,
            energy_min=sim_config["energy_range_min"].quantity[0],
            energy_max=sim_config["energy_range_max"].quantity[0],
            max_impact=sim_config["max_scatter_range"].quantity[0],
            spectral_index=sim_config["spectral_index"][0],
            viewcone_max=sim_config["max_viewcone_radius"].quantity[0],
            viewcone_min=sim_config["min_viewcone_radius"].quantity[0],
        )

        return sim_info, PowerLaw.from_simulation(sim_info, obstime=obs_time)

    def make_derived_columns(self, events: QTable) -> QTable:
        """
        Add derived quantities (e.g., theta, FOV offsets) to the table.

        Parameters
        ----------
        events : QTable
            Table containing normalized events.

        Returns
        -------
        QTable
            Table with added derived columns.
        """
        events["theta"] = calculate_theta(
            events,
            assumed_source_az=events["true_az"],
            assumed_source_alt=events["true_alt"],
        )
        events["true_source_fov_offset"] = calculate_source_fov_offset(
            events, prefix="true"
        )
        events["reco_source_fov_offset"] = calculate_source_fov_offset(
            events, prefix="reco"
        )

        pointing = SkyCoord(
            alt=events["pointing_alt"], az=events["pointing_az"], frame=AltAz()
        )
        reco = SkyCoord(alt=events["reco_alt"], az=events["reco_az"], frame=AltAz())
        nominal = NominalFrame(origin=pointing)
        reco_nominal = reco.transform_to(nominal)
        events["reco_fov_lon"] = u.Quantity(-reco_nominal.fov_lon)  # minus for GADF
        events["reco_fov_lat"] = u.Quantity(reco_nominal.fov_lat)
        events["weight"] = 1.0  # defer calculation of proper weights to later
        return events

    def make_event_weights(
        self,
        events: QTable,
        spectrum: "PowerLaw",
        kind: str,
        fov_offset_bins: u.Quantity | None = None,
    ) -> QTable:
        """
        Compute event weights to match the target spectrum.

        Parameters
        ----------
        events : QTable
            Input events.
        spectrum : PowerLaw
            Spectrum from simulation.
        kind : str
            Type of events ("gammas", etc.).
        fov_offset_bins : Quantity, optional
            Offset bins for integrating the diffuse flux into point source bins.

        Returns
        -------
        QTable
            Table with updated weights.

        Raises
        ------
        ValueError
            If ``fov_offset_bins`` is required but not provided.
        """
        if (
            kind == "gammas"
            and self.target_spectrum.normalization.unit.is_equivalent(
                POINT_SOURCE_FLUX_UNIT
            )
            and spectrum.normalization.unit.is_equivalent(DIFFUSE_FLUX_UNIT)
        ):
            if fov_offset_bins is None:
                raise ValueError(
                    "gamma_target_spectrum is point-like, but no fov offset bins "
                    "for the integration of the simulated diffuse spectrum were given."
                )

            for low, high in zip(fov_offset_bins[:-1], fov_offset_bins[1:]):
                fov_mask = events["true_source_fov_offset"] >= low
                fov_mask &= events["true_source_fov_offset"] < high

                events["weight"][fov_mask] = calculate_event_weights(
                    events[fov_mask]["true_energy"],
                    target_spectrum=self.target_spectrum,
                    simulated_spectrum=spectrum.integrate_cone(low, high),
                )
        else:
            events["weight"] = calculate_event_weights(
                events["true_energy"],
                target_spectrum=self.target_spectrum,
                simulated_spectrum=spectrum,
            )

        return events
