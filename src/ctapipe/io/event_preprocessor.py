"""Module containing classes related to event loading and preprocessing"""

from enum import StrEnum, auto

from astropy.coordinates import angular_separation
from traitlets import default

from ..coordinates import altaz_to_nominal
from ..core import (
    Component,
    FeatureGenerator,
    QualityQuery,
    ToolConfigurationError,
    traits,
)

__all__ = ["EventPreprocessor"]


class PreprocessorFeatureSet(StrEnum):
    """Pre-defined configurations for DL2EventPreprocessor for specific use cases."""

    custom = auto()  #: use user-supplied configuration
    dl2_irf = auto()  #: support IRF preprocessing use case


class EventPreprocessor(Component):
    """
    Selects or generates features and filters tables of events.

    In normal use, one only has to specify the ``feature_set`` option, which
    will generate features supports standard use cases. For advanced usage, you
    can set ``feature_set=custom`` and pass in a configured
    `~ctapipe.core.FeatureGenerator` and set the ``features`` property of this
    class with the columns you to retain in the output table.

    In the `~ctapipe.core.FeatureGenerator`` used internally, you have access to several
    additional functions useful for DL2 processing:

      - `~astropy.coordinates.angular_separation`
      - `~ctapipe.coordinates.altaz_to_nominal`
    """

    energy_reconstructor = traits.Unicode(
        default_value="RandomForestRegressor",
        help="Prefix of the reco `_energy` column",
    ).tag(config=True)

    geometry_reconstructor = traits.Unicode(
        default_value="HillasReconstructor",
        help="Prefix of the `_alt` and `_az` reco geometry columns",
    ).tag(config=True)

    gammaness_reconstructor = traits.Unicode(
        default_value="RandomForestClassifier",
        help="Prefix of the classifier `_prediction` column",
    ).tag(config=True)

    feature_set = traits.UseEnum(
        PreprocessorFeatureSet,
        default_value=PreprocessorFeatureSet.dl2_irf,
        help=(
            "Set up the FeatureGenerator.features, output features, and quality criteria "
            "based on standard use cases."
            "Specify 'custom' if you want to set your own in your config file. If this is set to "
            "any value other than 'custom', the feature properties of the configuration "
            "file you pass in will be overridden."
        ),
    ).tag(config=True)

    features = traits.List(
        traits.Unicode(),
        help=(
            "Features (columns) to retain in the output.  "
            "These can include columns generated by the FeatureGenerator. "
            "If you set these, make sure feature_set=custom."
        ),
    ).tag(config=True)

    def __init__(self, config=None, parent=None, **kwargs):
        super().__init__(config=config, parent=parent, **kwargs)
        if PreprocessorFeatureSet(self.feature_set) == PreprocessorFeatureSet.custom:
            self.feature_generator = FeatureGenerator(parent=self)
            self.quality_query = QualityQuery(parent=self)
        else:
            self.feature_generator = FeatureGenerator(
                features=self._get_predefined_features_to_generate()
            )
            self.quality_query = QualityQuery(
                quality_criteria=self._get_predefined_quality_criteria()
            )
        # sanity checks:
        if len(self.features) == 0:
            raise ToolConfigurationError(
                "DL2EventPreprocessor has no output features configured."
                "You have set `feature_set=custom`, but did not provide the list "
                "of features in the configuration (DL2EventPreprocessor.features)."
            )

    def __call__(self, table):
        """Return new table with only the columns in features."""

        # generate new features, which includes renaming columns:
        generated = self.feature_generator(
            table,
            angular_separation=angular_separation,
            altaz_to_nominal=altaz_to_nominal,
        )

        # apply event selection on the resulting table

        selected_mask = self.quality_query.get_table_mask(generated)

        # return only the columns specified in `self.features`, and rows in
        # `selected_mask`
        return generated[self.features][selected_mask]

    def _get_predefined_features_to_generate(self) -> list[tuple]:
        """Return a default list of FeatureGenerator features."""
        if self.feature_set == PreprocessorFeatureSet.dl2_irf:
            # Default features for DL2/Subarray events
            return [
                ("reco_energy", f"{self.energy_reconstructor}_energy"),
                ("reco_alt", f"{self.geometry_reconstructor}_alt"),
                ("reco_az", f"{self.geometry_reconstructor}_az"),
                ("gh_score", f"{self.gammaness_reconstructor}_prediction"),
                ("theta", "angular_separation(reco_az, reco_alt, true_az, true_alt)"),
                (
                    "reco_fov_coord",
                    "altaz_to_nominal(reco_az, reco_alt, subarray_pointing_lon, subarray_pointing_lat)",
                ),
                (
                    "reco_fov_lon",
                    "reco_fov_coord[:,0]",
                ),  # note: GADF IRFs use the negative of this
                ("reco_fov_lat", "reco_fov_coord[:,1]"),
                (
                    "true_fov_coord",
                    "altaz_to_nominal(true_az, true_alt, subarray_pointing_lon, subarray_pointing_lat)",
                ),
                (
                    "true_fov_lon",
                    "true_fov_coord[:,0]",
                ),  # note: GADF IRFs use the negative of this
                ("true_fov_lat", "true_fov_coord[:,1]"),
                (
                    "true_fov_offset",
                    "angular_separation(reco_fov_lon, reco_fov_lat, 0*u.deg, 0*u.deg)",
                ),
                (
                    "reco_fov_offset",
                    "angular_separation(true_fov_lon, reco_fov_lat, 0*u.deg, 0*u.deg)",
                ),
                (
                    "multiplicity",
                    f"np.count_nonzero({self.gammaness_reconstructor}_telescopes,axis=1)",
                ),
            ]
        else:
            raise NotImplementedError(f"unsupported feature_set: {self.feature_set}")

    def _get_predefined_quality_criteria(self) -> list[tuple]:
        """
        Set the quality criteria for a DL2FeatureSet.

        Here you can use any columns in the input table, or any that are
        specified in the FeatureGenerator.
        """
        if self.feature_set == PreprocessorFeatureSet.dl2_irf:
            return [
                ("Valid geometry", f"{self.geometry_reconstructor}_is_valid"),
                ("valid energy", f"{self.energy_reconstructor}_is_valid"),
                ("valid gammaness", f"{self.gammaness_reconstructor}_is_valid"),
                ("sufficient multiplicity", "multiplicity >= 4"),
            ]
        else:
            raise NotImplementedError(f"unsupported feature_set: {self.feature_set}")

    @default("features")
    def default_features(self):
        """Set the columns to output, for a given FeatureSet."""
        if self.feature_set == PreprocessorFeatureSet.dl2_irf:
            return [
                "event_id",
                "obs_id",
                "reco_energy",
                "reco_alt",
                "reco_az",
                "gh_score",
                "true_energy",
                "true_alt",
                "true_az",
                "true_fov_offset",
                "reco_fov_offset",
                "theta",
                "reco_fov_lat",
                "true_fov_lat",
                "reco_fov_lon",
                "true_fov_lon",
                "multiplicity",
            ]
        elif self.feature_set == PreprocessorFeatureSet.custom:
            return []
        else:
            raise NotImplementedError(f"unsupported feature_set: {self.feature_set}")
