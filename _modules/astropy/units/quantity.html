<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>astropy.units.quantity &mdash; ctapipe v0.17.1.dev630+g3afb8e35.d20230209</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ctapipe
          </a>
              <div class="version">
                0.17.1.dev630+g3afb8e35.d20230209
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started_users/index.html">Getting Started For Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/index.html">Getting Started For Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../development/index.html">Development Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">Command-Line Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../FAQ.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data_models/index.html">Data Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ctapipe_api/index.html">API Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ctapipe</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">astropy.units.quantity</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for astropy.units.quantity</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the `Quantity` object, which represents a number with some</span>
<span class="sd">associated units. `Quantity` objects support operations like ordinary numbers,</span>
<span class="sd">but will deal with unit conversions internally.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># STDLIB</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>

<span class="c1"># THIRD PARTY</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># LOCAL</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">config</span> <span class="k">as</span> <span class="n">_config</span>
<span class="kn">from</span> <span class="nn">astropy.utils.compat</span> <span class="kn">import</span> <span class="n">NUMPY_LT_1_22</span>
<span class="kn">from</span> <span class="nn">astropy.utils.data_info</span> <span class="kn">import</span> <span class="n">ParentDtypeInfo</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyDeprecationWarning</span><span class="p">,</span> <span class="n">AstropyWarning</span>
<span class="kn">from</span> <span class="nn">astropy.utils.misc</span> <span class="kn">import</span> <span class="n">isiterable</span>

<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Unit</span><span class="p">,</span>
    <span class="n">UnitBase</span><span class="p">,</span>
    <span class="n">UnitConversionError</span><span class="p">,</span>
    <span class="n">UnitsError</span><span class="p">,</span>
    <span class="n">UnitTypeError</span><span class="p">,</span>
    <span class="n">dimensionless_unscaled</span><span class="p">,</span>
    <span class="n">get_current_unit_registry</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.format</span> <span class="kn">import</span> <span class="n">Base</span><span class="p">,</span> <span class="n">Latex</span>
<span class="kn">from</span> <span class="nn">.quantity_helper</span> <span class="kn">import</span> <span class="n">can_have_arbitrary_unit</span><span class="p">,</span> <span class="n">check_output</span><span class="p">,</span> <span class="n">converters_and_unit</span>
<span class="kn">from</span> <span class="nn">.quantity_helper.function_helpers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DISPATCHED_FUNCTIONS</span><span class="p">,</span>
    <span class="n">FUNCTION_HELPERS</span><span class="p">,</span>
    <span class="n">SUBCLASS_SAFE_FUNCTIONS</span><span class="p">,</span>
    <span class="n">UNSUPPORTED_FUNCTIONS</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.structured</span> <span class="kn">import</span> <span class="n">StructuredUnit</span><span class="p">,</span> <span class="n">_structured_unit_like_dtype</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">is_effectively_unity</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Quantity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SpecificTypeQuantity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;QuantityInfoBase&quot;</span><span class="p">,</span>
    <span class="s2">&quot;QuantityInfo&quot;</span><span class="p">,</span>
    <span class="s2">&quot;allclose&quot;</span><span class="p">,</span>
    <span class="s2">&quot;isclose&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1"># We don&#39;t want to run doctests in the docstrings we inherit from Numpy</span>
<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Quantity.*&quot;</span><span class="p">]</span>

<span class="n">_UNIT_NOT_INITIALISED</span> <span class="o">=</span> <span class="s2">&quot;(Unit not initialised)&quot;</span>
<span class="n">_UFUNCS_FILTER_WARNINGS</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">Conf</span><span class="p">(</span><span class="n">_config</span><span class="o">.</span><span class="n">ConfigNamespace</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configuration parameters for Quantity</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">latex_array_threshold</span> <span class="o">=</span> <span class="n">_config</span><span class="o">.</span><span class="n">ConfigItem</span><span class="p">(</span>
        <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;The maximum size an array Quantity can be before its LaTeX &quot;</span>
        <span class="s1">&#39;representation for IPython gets &quot;summarized&quot; (meaning only the first &#39;</span>
        <span class="s1">&#39;and last few elements are shown with &quot;...&quot; between). Setting this to a &#39;</span>
        <span class="s2">&quot;negative number means that the value will instead be whatever numpy &quot;</span>
        <span class="s2">&quot;gets from get_printoptions.&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="n">conf</span> <span class="o">=</span> <span class="n">Conf</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">QuantityIterator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flat iterator object to iterate over Quantities</span>

<span class="sd">    A `QuantityIterator` iterator is returned by ``q.flat`` for any Quantity</span>
<span class="sd">    ``q``.  It allows iterating over the array as if it were a 1-D array,</span>
<span class="sd">    either in a for-loop or by calling its `next` method.</span>

<span class="sd">    Iteration is done in C-contiguous style, with the last index varying the</span>
<span class="sd">    fastest. The iterator can also be indexed using basic slicing or</span>
<span class="sd">    advanced indexing.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Quantity.flatten : Returns a flattened copy of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `QuantityIterator` is inspired by `~numpy.ma.core.MaskedIterator`.  It</span>
<span class="sd">    is not exported by the `~astropy.units` module.  Instead of</span>
<span class="sd">    instantiating a `QuantityIterator` directly, use `Quantity.flat`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
        <span class="c1"># For single elements, ndarray.flat.__getitem__ returns scalars; these</span>
        <span class="c1"># need a new view as a Quantity.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the next value, or raise StopIteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="p">)</span>
        <span class="c1"># ndarray.flat._dataiter returns scalars, so need a view as a Quantity.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="p">)</span>

    <span class="c1">#### properties and methods to match `numpy.ndarray.flatiter` ####</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A reference to the array that is iterated over.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An N-dimensional tuple of current coordinates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="o">.</span><span class="n">coords</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Current flat index into the array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataiter</span><span class="o">.</span><span class="n">index</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a copy of the iterator as a 1-D array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quantity</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">QuantityInfoBase</span><span class="p">(</span><span class="n">ParentDtypeInfo</span><span class="p">):</span>
    <span class="c1"># This is on a base class rather than QuantityInfo directly, so that</span>
    <span class="c1"># it can be used for EarthLocationInfo yet make clear that that class</span>
    <span class="c1"># should not be considered a typical Quantity subclass by Table.</span>
    <span class="n">attrs_from_parent</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">}</span>  <span class="c1"># dtype and unit taken from parent</span>
    <span class="n">_supports_indexing</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_format</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">possible_string_format_functions</span><span class="p">(</span><span class="n">format_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate through possible string-derived format functions.</span>

<span class="sd">        A string can either be a format specifier for the format built-in,</span>
<span class="sd">        a new-style format string, or an old-style format string.</span>

<span class="sd">        This method is overridden in order to suppress printing the unit</span>
<span class="sd">        in each row since it is already at the top in the column header.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">format</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">format_</span><span class="p">)</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">format_</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">yield</span> <span class="k">lambda</span> <span class="n">format_</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">format_</span> <span class="o">%</span> <span class="n">val</span><span class="o">.</span><span class="n">value</span>


<span class="k">class</span> <span class="nc">QuantityInfo</span><span class="p">(</span><span class="n">QuantityInfoBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for meta information like name, description, format.  This is</span>
<span class="sd">    required when the object is used as a mixin column within a table, but can</span>
<span class="sd">    be used as a general way to store meta information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_represent_as_dict_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span>
    <span class="n">_construct_from_dict_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
    <span class="n">_represent_as_dict_primary_data</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span>

    <span class="k">def</span> <span class="nf">new_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">metadata_conflicts</span><span class="o">=</span><span class="s2">&quot;warn&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Quantity instance which is consistent with the</span>
<span class="sd">        input ``cols`` and has ``length`` rows.</span>

<span class="sd">        This is intended for creating an empty column object whose elements can</span>
<span class="sd">        be set in-place for table operations like join or vstack.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cols : list</span>
<span class="sd">            List of input columns</span>
<span class="sd">        length : int</span>
<span class="sd">            Length of the output column object</span>
<span class="sd">        metadata_conflicts : str (&#39;warn&#39;|&#39;error&#39;|&#39;silent&#39;)</span>
<span class="sd">            How to handle metadata conflicts</span>
<span class="sd">        name : str</span>
<span class="sd">            Output column name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col : `~astropy.units.Quantity` (or subclass)</span>
<span class="sd">            Empty instance of this class consistent with ``cols``</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get merged info attributes like shape, dtype, format, description, etc.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_cols_attributes</span><span class="p">(</span>
            <span class="n">cols</span><span class="p">,</span> <span class="n">metadata_conflicts</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;meta&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Make an empty quantity using the unit of the last one.</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span><span class="p">,)</span> <span class="o">+</span> <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;shape&quot;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">)</span>
        <span class="c1"># Use zeros so we do not get problems for Quantity subclasses such</span>
        <span class="c1"># as Longitude and Latitude, which cannot take arbitrary values.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Get arguments needed to reconstruct class</span>
        <span class="nb">map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="p">(</span><span class="n">data</span> <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span> <span class="k">else</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_represent_as_dict_attrs</span>
        <span class="p">}</span>
        <span class="nb">map</span><span class="p">[</span><span class="s2">&quot;copy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_dict</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

        <span class="c1"># Set remaining info attributes</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">get_sortable_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of arrays which can be lexically sorted to represent</span>
<span class="sd">        the order of the parent column.</span>

<span class="sd">        For Quantity this is just the quantity itself.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arrays : list of ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A `~astropy.units.Quantity` represents a number with some associated unit.</span>

<span class="sd">    See also: https://docs.astropy.org/en/stable/units/quantity.html</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str</span>
<span class="sd">        The numerical value of this quantity in the units given by unit.  If a</span>
<span class="sd">        `Quantity` or sequence of them (or any other valid object with a</span>
<span class="sd">        ``unit`` attribute), creates a new `Quantity` object, converting to</span>
<span class="sd">        `unit` units as needed.  If a string, it is converted to a number or</span>
<span class="sd">        `Quantity`, depending on whether a unit is present.</span>

<span class="sd">    unit : unit-like</span>
<span class="sd">        An object that represents the unit associated with the input value.</span>
<span class="sd">        Must be an `~astropy.units.UnitBase` object or a string parseable by</span>
<span class="sd">        the :mod:`~astropy.units` package.</span>

<span class="sd">    dtype : ~numpy.dtype, optional</span>
<span class="sd">        The dtype of the resulting Numpy array or scalar that will</span>
<span class="sd">        hold the value.  If not provided, it is determined from the input,</span>
<span class="sd">        except that any integer and (non-Quantity) object inputs are converted</span>
<span class="sd">        to float by default.</span>
<span class="sd">        If `None`, the normal `numpy.dtype` introspection is used, e.g.</span>
<span class="sd">        preventing upcasting of integers.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), then the value is copied.  Otherwise, a copy will</span>
<span class="sd">        only be made if ``__array__`` returns a copy, if value is a nested</span>
<span class="sd">        sequence, or if a copy is needed to satisfy an explicitly given</span>
<span class="sd">        ``dtype``.  (The `False` option is intended mostly for internal use,</span>
<span class="sd">        to speed up initialization where a copy is known to have been made.</span>
<span class="sd">        Use with care.)</span>

<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}, optional</span>
<span class="sd">        Specify the order of the array.  As in `~numpy.array`.  This parameter</span>
<span class="sd">        is ignored if the input is a `Quantity` and ``copy=False``.</span>

<span class="sd">    subok : bool, optional</span>
<span class="sd">        If `False` (default), the returned array will be forced to be a</span>
<span class="sd">        `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,</span>
<span class="sd">        or a subclass appropriate for the unit will be used (such as</span>
<span class="sd">        `~astropy.units.Dex` for ``u.dex(u.AA)``).</span>

<span class="sd">    ndmin : int, optional</span>
<span class="sd">        Specifies the minimum number of dimensions that the resulting array</span>
<span class="sd">        should have.  Ones will be pre-pended to the shape as needed to meet</span>
<span class="sd">        this requirement.  This parameter is ignored if the input is a</span>
<span class="sd">        `Quantity` and ``copy=False``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the value provided is not a Python numeric type.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the unit provided is not either a :class:`~astropy.units.Unit`</span>
<span class="sd">        object or a parseable string unit.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Quantities can also be created by multiplying a number or array with a</span>
<span class="sd">    :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/</span>

<span class="sd">    Unless the ``dtype`` argument is explicitly specified, integer</span>
<span class="sd">    or (non-Quantity) object inputs are converted to `float` by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Need to set a class-level default for _equivalencies, or</span>
    <span class="c1"># Constants can not initialize properly</span>
    <span class="n">_equivalencies</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Default unit for initialization; can be overridden by subclasses,</span>
    <span class="c1"># possibly to `None` to indicate there is no default unit.</span>
    <span class="n">_default_unit</span> <span class="o">=</span> <span class="n">dimensionless_unscaled</span>

    <span class="c1"># Ensures views have an undefined unit.</span>
    <span class="n">_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="k">def</span> <span class="nf">__class_getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">unit_shape_dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Quantity Type Hints.</span>

<span class="sd">        Unit-aware type hints are ``Annotated`` objects that encode the class,</span>
<span class="sd">        the unit, and possibly shape and dtype information, depending on the</span>
<span class="sd">        python and :mod:`numpy` versions.</span>

<span class="sd">        Schematically, ``Annotated[cls[shape, dtype], unit]``</span>

<span class="sd">        As a classmethod, the type is the class, ie ``Quantity``</span>
<span class="sd">        produces an ``Annotated[Quantity, ...]`` while a subclass</span>
<span class="sd">        like :class:`~astropy.coordinates.Angle` returns</span>
<span class="sd">        ``Annotated[Angle, ...]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple</span>
<span class="sd">            Unit specification, can be the physical type (ie str or class).</span>
<span class="sd">            If tuple, then the first element is the unit specification</span>
<span class="sd">            and all other elements are for `numpy.ndarray` type annotations.</span>
<span class="sd">            Whether they are included depends on the python and :mod:`numpy`</span>
<span class="sd">            versions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `typing.Annotated`, `typing_extensions.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`</span>
<span class="sd">            Return type in this preference order:</span>
<span class="sd">            * if python v3.9+ : `typing.Annotated`</span>
<span class="sd">            * if :mod:`typing_extensions` is installed : `typing_extensions.Annotated`</span>
<span class="sd">            * `astropy.units.Unit` or `astropy.units.PhysicalType`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the unit/physical_type annotation is not Unit-like or</span>
<span class="sd">            PhysicalType-like.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a unit-aware Quantity type annotation</span>

<span class="sd">            &gt;&gt;&gt; Quantity[Unit(&quot;s&quot;)]</span>
<span class="sd">            Annotated[Quantity, Unit(&quot;s&quot;)]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        `~astropy.units.quantity_input`</span>
<span class="sd">            Use annotations for unit checks on function arguments and results.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        With Python 3.9+ or :mod:`typing_extensions`, |Quantity| types are also</span>
<span class="sd">        static-type compatible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># LOCAL</span>
        <span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">HAS_ANNOTATED</span><span class="p">,</span> <span class="n">Annotated</span>

        <span class="c1"># process whether [unit] or [unit, shape, ptype]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit_shape_dtype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># unit, shape, dtype</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">unit_shape_dtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">shape_dtype</span> <span class="o">=</span> <span class="n">unit_shape_dtype</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># just unit</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">unit_shape_dtype</span>
            <span class="n">shape_dtype</span> <span class="o">=</span> <span class="p">()</span>

        <span class="c1"># Allowed unit/physical types. Errors if neither.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">astropy.units.physical</span> <span class="kn">import</span> <span class="n">get_physical_type</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">get_physical_type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>  <span class="c1"># KeyError for Enum</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unit annotation is not a Unit or PhysicalType&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="c1"># Allow to sort of work for python 3.8- / no typing_extensions</span>
        <span class="c1"># instead of bailing out, return the unit for `quantity_input`</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_ANNOTATED</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Quantity annotations are valid static type annotations only&quot;</span>
                <span class="s2">&quot; if Python is v3.9+ or `typing_extensions` is installed.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">unit</span>

        <span class="c1"># Quantity does not (yet) properly extend the NumPy generics types,</span>
        <span class="c1"># introduced in numpy v1.22+, instead just including the unit info as</span>
        <span class="c1"># metadata using Annotated.</span>
        <span class="c1"># TODO: ensure we do interact with NDArray.__class_getitem__.</span>
        <span class="k">return</span> <span class="n">Annotated</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">((</span><span class="bp">cls</span><span class="p">,</span> <span class="n">unit</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">value</span><span class="p">,</span>
        <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># convert unit first, to avoid multiple string-&gt;unit conversions</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># inexact -&gt; upcast to float dtype</span>
        <span class="n">float_default</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span>
        <span class="k">if</span> <span class="n">float_default</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># optimize speed for Quantity with no dtype given, copy=False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
                <span class="c1"># the above already makes a copy (with float dtype)</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">cls</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">subok</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">float_default</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;iu&quot;</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span>
            <span class="p">)</span>

        <span class="c1"># Maybe str, or list/tuple of Quantity? If so, this may set value_unit.</span>
        <span class="c1"># To ensure array remains fast, we short-circuit it.</span>
        <span class="n">value_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># The first part of the regex string matches any integer/float;</span>
                <span class="c1"># the second parts adds possible trailing .+-, which will break</span>
                <span class="c1"># the float function below and ensure things like 1.2.3deg</span>
                <span class="c1"># will not work.</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;\s*[+-]?&quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;((\d+\.?\d*)|(\.\d+)|([nN][aA][nN])|&quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))&quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;([eE][+-]?\d+)?&quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;[.+-]?&quot;</span>
                <span class="p">)</span>

                <span class="n">v</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">unit_string</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>

                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Cannot parse &quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&quot; as a </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">. It does not &#39;</span>
                        <span class="s2">&quot;start with a number.&quot;</span>
                    <span class="p">)</span>

                <span class="n">unit_string</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">unit_string</span><span class="p">:</span>
                    <span class="n">value_unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit_string</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="n">value_unit</span>  <span class="c1"># signal no conversion needed below.</span>

            <span class="k">elif</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Iterables like lists and tuples.</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">):</span>
                    <span class="c1"># If a list/tuple containing only quantities, convert all</span>
                    <span class="c1"># to the same unit.</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
                    <span class="n">value_unit</span> <span class="o">=</span> <span class="n">unit</span>  <span class="c1"># signal below that conversion has been done</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1"># Special case for list/tuple of values and a structured unit:</span>
                    <span class="c1"># ``np.array(value, dtype=None)`` would treat tuples as lower</span>
                    <span class="c1"># levels of the array, rather than as elements of a structured</span>
                    <span class="c1"># array, so we use the structure of the unit to help infer the</span>
                    <span class="c1"># structured dtype of the value.</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">_recursively_get_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">using_default_unit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">value_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the value has a `unit` attribute and if not None</span>
            <span class="c1"># (for Columns with uninitialized unit), treat it like a quantity.</span>
            <span class="n">value_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Default to dimensionless for no (initialized) unit attribute.</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">using_default_unit</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_unit</span>
                <span class="n">value_unit</span> <span class="o">=</span> <span class="n">unit</span>  <span class="c1"># signal below that no conversion is needed</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value_unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">value_unit</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The unit attribute </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="si">!r}</span><span class="s2"> of the input could &quot;</span>
                        <span class="s2">&quot;not be parsed as an astropy Unit.&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>

                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">value_unit</span>
                <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value_unit</span><span class="p">:</span>
                    <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># copy will be made in conversion at end</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span>
        <span class="p">)</span>

        <span class="c1"># For no-user-input unit, make sure the constructed unit matches the</span>
        <span class="c1"># structure of the data.</span>
        <span class="k">if</span> <span class="n">using_default_unit</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">value_unit</span> <span class="o">=</span> <span class="n">_structured_unit_like_dtype</span><span class="p">(</span><span class="n">value_unit</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># check that array contains numbers or long int objects</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;OSU&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The value must be a valid Python or Numpy numeric type.&quot;</span><span class="p">)</span>

        <span class="c1"># by default, cast any integer, boolean, etc., to float</span>
        <span class="k">if</span> <span class="n">float_default</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;iuO&quot;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># if we allow subclasses, allow a class from the unit.</span>
        <span class="k">if</span> <span class="n">subok</span><span class="p">:</span>
            <span class="n">qcls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s2">&quot;_quantity_class&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">qcls</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">qcls</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">value</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">value_unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="n">value_unit</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># here we had non-Quantity input that had a &quot;unit&quot; attribute</span>
            <span class="c1"># with a unit different from the desired one.  So, convert.</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># Check whether super().__array_finalize should be called</span>
        <span class="c1"># (sadly, ndarray.__array_finalize__ is None; we cannot be sure</span>
        <span class="c1"># what is above us).</span>
        <span class="n">super_array_finalize</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_finalize__</span>
        <span class="k">if</span> <span class="n">super_array_finalize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">super_array_finalize</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="c1"># If we&#39;re a new object or viewing an ndarray, nothing has to be done.</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># If our unit is not set and obj has a valid one, use it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;_unit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># Copy info if the original had `info` defined.  Because of the way the</span>
        <span class="c1"># DataInfo works, `&#39;info&#39; in obj.__dict__` is False until the</span>
        <span class="c1"># `info` attribute is accessed or set.</span>
        <span class="k">if</span> <span class="s2">&quot;info&quot;</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">info</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Methods like .squeeze() created a new `ndarray` and then call</span>
            <span class="c1"># __array_wrap__ to turn the array into self&#39;s subclass.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;__array_wrap__ should not be used with a context any more since all &quot;</span>
            <span class="s2">&quot;use should go through array_function. Please raise an issue on &quot;</span>
            <span class="s2">&quot;https://github.com/astropy/astropy&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap numpy ufuncs, taking care of units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            ufunc to wrap.</span>
<span class="sd">        method : str</span>
<span class="sd">            Ufunc method: ``__call__``, ``at``, ``reduce``, etc.</span>
<span class="sd">        inputs : tuple</span>
<span class="sd">            Input arrays.</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            As passed on, with ``out`` containing possible quantity output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : `~astropy.units.Quantity`</span>
<span class="sd">            Results of the ufunc, with the unit set properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine required conversion functions -- to bring the unit of the</span>
        <span class="c1"># input to that expected (e.g., radian for np.sin), or to get</span>
        <span class="c1"># consistent units between two inputs (e.g., in np.add) --</span>
        <span class="c1"># and the unit of the result (or tuple of units for nout &gt; 1).</span>
        <span class="n">converters</span><span class="p">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">converters_and_unit</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Avoid loop back by turning any Quantity output into array views.</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If pre-allocated output is used, check it is suitable.</span>
            <span class="c1"># This also returns array view, to ensure we don&#39;t loop back.</span>
            <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out_array</span> <span class="o">=</span> <span class="n">check_output</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
            <span class="c1"># Ensure output argument remains a tuple.</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_array</span><span class="p">,)</span> <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">out_array</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;reduce&quot;</span> <span class="ow">and</span> <span class="s2">&quot;initial&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Special-case for initial argument for reductions like</span>
            <span class="c1"># np.add.reduce.  This should be converted to the output unit as</span>
            <span class="c1"># well, which is typically the same as the input unit (but can</span>
            <span class="c1"># in principle be different: unitless for np.equal, radian</span>
            <span class="c1"># for np.arctan2, though those are not necessarily useful!)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;initial&quot;</span><span class="p">],</span> <span class="n">check_precision</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span>
            <span class="p">)</span>

        <span class="c1"># Same for inputs, but here also convert if necessary.</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">input_</span><span class="p">,</span> <span class="n">converter</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">converters</span><span class="p">):</span>
            <span class="n">input_</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">input_</span><span class="p">)</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">converter</span><span class="p">(</span><span class="n">input_</span><span class="p">)</span> <span class="k">if</span> <span class="n">converter</span> <span class="k">else</span> <span class="n">input_</span><span class="p">)</span>

        <span class="c1"># Call our superclass&#39;s __array_ufunc__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># If unit is None, a plain array is expected (e.g., comparisons), which</span>
        <span class="c1"># means we&#39;re done.</span>
        <span class="c1"># We&#39;re also done if the result was None (for method &#39;at&#39;) or</span>
        <span class="c1"># NotImplemented, which can happen if other inputs/outputs override</span>
        <span class="c1"># __array_ufunc__; hopefully, they can then deal with us.</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_result_as_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Turn result into a quantity with the given unit.</span>

<span class="sd">        If no output is given, it will take a view of the array as a quantity,</span>
<span class="sd">        and set the unit.  If output is given, those should be quantity views</span>
<span class="sd">        of the result arrays, and the function will just set the unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : ndarray or tuple thereof</span>
<span class="sd">            Array(s) which need to be turned into quantity.</span>
<span class="sd">        unit : `~astropy.units.Unit`</span>
<span class="sd">            Unit for the quantities to be returned (or `None` if the result</span>
<span class="sd">            should not be a quantity).  Should be tuple if result is a tuple.</span>
<span class="sd">        out : `~astropy.units.Quantity` or None</span>
<span class="sd">            Possible output quantity. Should be `None` or a tuple if result</span>
<span class="sd">            is a tuple.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">           With units set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">unit_</span><span class="p">,</span> <span class="n">out_</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">result_</span><span class="p">,</span> <span class="n">unit_</span><span class="p">,</span> <span class="n">out_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># View the result array as a Quantity with the proper unit.</span>
            <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="c1"># For given Quantity output, just set the unit. We know the unit</span>
            <span class="c1"># is not None and the output is of the correct Quantity subclass,</span>
            <span class="c1"># as it was passed through check_output.</span>
            <span class="c1"># (We cannot do this unconditionally, though, since it is possible</span>
            <span class="c1"># for out to be ndarray and the unit to be dimensionless.)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__quantity_subclass__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overridden by subclasses to change what kind of view is</span>
<span class="sd">        created based on the output unit of an operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : UnitBase</span>
<span class="sd">            The unit for which the appropriate class should be returned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple :</span>
<span class="sd">            - `~astropy.units.Quantity` subclass</span>
<span class="sd">            - bool: True if subclasses of the given class are ok</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Quantity</span><span class="p">,</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Quantity view of some array-like input, and set the unit</span>

<span class="sd">        By default, return a view of ``obj`` of the same class as ``self`` and</span>
<span class="sd">        with the same unit.  Subclasses can override the type of class for a</span>
<span class="sd">        given unit using ``__quantity_subclass__``, and can ensure properties</span>
<span class="sd">        other than the unit are copied using ``__array_finalize__``.</span>

<span class="sd">        If the given unit defines a ``_quantity_class`` of which ``self``</span>
<span class="sd">        is not an instance, a view using this class is taken.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : ndarray or scalar, optional</span>
<span class="sd">            The array to create a view of.  If obj is a numpy or python scalar,</span>
<span class="sd">            it will be converted to an array scalar.  By default, ``self``</span>
<span class="sd">            is converted.</span>

<span class="sd">        unit : unit-like, optional</span>
<span class="sd">            The unit of the resulting object.  It is used to select a</span>
<span class="sd">            subclass, and explicitly assigned to the view if given.</span>
<span class="sd">            If not given, the subclass and unit will be that of ``self``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        view : `~astropy.units.Quantity` subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the unit and quantity subclass that we need for the view.</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">Quantity</span><span class="p">:</span>
            <span class="c1"># The second part is because we should not presume what other</span>
            <span class="c1"># classes want to do for the same unit.  E.g., Constant will</span>
            <span class="c1"># always want to fall back to Quantity, and relies on going</span>
            <span class="c1"># through `__quantity_subclass__`.</span>
            <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="n">Quantity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s2">&quot;_quantity_class&quot;</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity_subclass</span><span class="p">):</span>
                <span class="n">quantity_subclass</span><span class="p">,</span> <span class="n">subok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__quantity_subclass__</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">subok</span><span class="p">:</span>
                    <span class="n">quantity_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>

        <span class="c1"># We only want to propagate information from ``self`` to our new view,</span>
        <span class="c1"># so obj should be a regular array.  By using ``np.array``, we also</span>
        <span class="c1"># convert python and numpy scalars, which cannot be viewed as arrays</span>
        <span class="c1"># and thus not as Quantity either, to zero-dimensional arrays.</span>
        <span class="c1"># (These are turned back into scalar in `.value`)</span>
        <span class="c1"># Note that for an ndarray input, the np.array call takes only double</span>
        <span class="c1"># ``obj.__class is np.ndarray``. So, not worth special-casing.</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Take the view, set the unit, and update possible other properties</span>
        <span class="c1"># such as ``info``, ``wrap_angle`` in `Longitude`, etc.</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">quantity_subclass</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span> <span class="nf">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the unit.</span>

<span class="sd">        This is used anywhere the unit is set or modified, i.e., in the</span>
<span class="sd">        initilizer, in ``__imul__`` and ``__itruediv__`` for in-place</span>
<span class="sd">        multiplication and division by another unit, as well as in</span>
<span class="sd">        ``__array_finalize__`` for wrapping up views.  For Quantity, it just</span>
<span class="sd">        sets the unit, but subclasses can override it to check that, e.g.,</span>
<span class="sd">        a unit is consistent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">UnitBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">unit</span><span class="p">,</span> <span class="n">StructuredUnit</span>
            <span class="p">):</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">StructuredUnit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Trying to go through a string ensures that, e.g., Magnitudes with</span>
                <span class="c1"># dimensionless physical unit become Quantity with units of mag.</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="n">parse_strict</span><span class="o">=</span><span class="s2">&quot;silent&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="n">UnitTypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> instances require normal units, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="n">unit</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2"> instances.&quot;</span>
                    <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">unit</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="c1"># If we don&#39;t define this, ``copy.deepcopy(quantity)`` will</span>
        <span class="c1"># return a bare Numpy array.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># patch to pickle Quantity objects (ndarray subclasses), see</span>
        <span class="c1"># http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html</span>

        <span class="n">object_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">())</span>
        <span class="n">object_state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_state</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">object_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># patch to unpickle Quantity objects (ndarray subclasses), see</span>
        <span class="c1"># http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html</span>

        <span class="n">nd_state</span><span class="p">,</span> <span class="n">own_state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">nd_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">own_state</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">QuantityInfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method for to and to_value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">equivalencies</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">equivalencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalencies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">):</span>
            <span class="c1"># Standard path, let unit to do work.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                <span class="n">unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">equivalencies</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The .to() method of a simple unit cannot convert a structured</span>
            <span class="c1"># dtype, so we work around it, by recursing.</span>
            <span class="c1"># TODO: deprecate this?</span>
            <span class="c1"># Convert simple to Structured on initialization?</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new `~astropy.units.Quantity` object with the specified unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : unit-like</span>
<span class="sd">            An object that represents the unit to convert to. Must be</span>
<span class="sd">            an `~astropy.units.UnitBase` object or a string parseable</span>
<span class="sd">            by the `~astropy.units` package.</span>

<span class="sd">        equivalencies : list of tuple</span>
<span class="sd">            A list of equivalence pairs to try if the units are not</span>
<span class="sd">            directly convertible.  See :ref:`astropy:unit_equivalencies`.</span>
<span class="sd">            If not provided or ``[]``, class default equivalencies will be used</span>
<span class="sd">            (none for `~astropy.units.Quantity`, but may be set for subclasses)</span>
<span class="sd">            If `None`, no equivalencies will be applied at all, not even any</span>
<span class="sd">            set globally or within a context.</span>

<span class="sd">        copy : bool, optional</span>
<span class="sd">            If `True` (default), then the value is copied.  Otherwise, a copy</span>
<span class="sd">            will only be made if necessary.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        to_value : get the numerical value in a given unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We don&#39;t use `to_value` below since we always want to make a copy</span>
        <span class="c1"># and don&#39;t want to slow down this method (esp. the scalar case).</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="c1"># Avoid using to_value to ensure that we make a copy. We also</span>
            <span class="c1"># don&#39;t want to slow down this method (esp. the scalar case).</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># to_value only copies if necessary</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The numerical value, possibly in a different unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : unit-like, optional</span>
<span class="sd">            The unit in which the value should be given. If not given or `None`,</span>
<span class="sd">            use the current unit.</span>

<span class="sd">        equivalencies : list of tuple, optional</span>
<span class="sd">            A list of equivalence pairs to try if the units are not directly</span>
<span class="sd">            convertible (see :ref:`astropy:unit_equivalencies`). If not provided</span>
<span class="sd">            or ``[]``, class default equivalencies will be used (none for</span>
<span class="sd">            `~astropy.units.Quantity`, but may be set for subclasses).</span>
<span class="sd">            If `None`, no equivalencies will be applied at all, not even any</span>
<span class="sd">            set globally or within a context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : ndarray or scalar</span>
<span class="sd">            The value in the units specified. For arrays, this will be a view</span>
<span class="sd">            of the data if no unit conversion was necessary.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        to : Get a new instance in a different unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unit</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="c1"># For non-structured, we attempt a short-cut, where we just get</span>
            <span class="c1"># the scale.  If that is 1, we do not have to do anything.</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="c1"># We want a view if the unit does not change.  One could check</span>
            <span class="c1"># with &quot;==&quot;, but that calculates the scale that we need anyway.</span>
            <span class="c1"># TODO: would be better for `unit.to` to have an in-place flag.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># Short-cut failed; try default (maybe equivalencies help).</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_effectively_unity</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
                    <span class="c1"># not in-place!</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For structured arrays, we go the default route.</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">)</span>

        <span class="c1"># Index with empty tuple to decay array scalars in to numpy scalars.</span>
        <span class="k">return</span> <span class="n">value</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> <span class="n">value</span><span class="p">[()]</span>

    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">to_value</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The numerical value of this instance.</span>

<span class="s2">    See also</span>
<span class="s2">    --------</span>
<span class="s2">    to_value : Get the numerical value in a given unit.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `~astropy.units.UnitBase` object representing the unit of this</span>
<span class="sd">        quantity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of equivalencies that will be applied by default during</span>
<span class="sd">        unit conversions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalencies</span>

    <span class="k">def</span> <span class="nf">_recursively_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply function recursively to every field.</span>

<span class="sd">        Returns a copy with the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">result_value</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">result_unit</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">result_value</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">value</span>
            <span class="n">result_unit</span> <span class="o">+=</span> <span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">unit</span><span class="p">,)</span>

        <span class="n">result</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">result_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">si</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the current `Quantity` instance with SI units. The</span>
<span class="sd">        value of the resulting object will be scaled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursively_apply</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;si&quot;</span><span class="p">))</span>
        <span class="n">si_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">si</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">si_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">si_unit</span> <span class="o">/</span> <span class="n">si_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cgs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the current `Quantity` instance with CGS units. The</span>
<span class="sd">        value of the resulting object will be scaled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursively_apply</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;cgs&quot;</span><span class="p">))</span>
        <span class="n">cgs_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">cgs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">cgs_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">cgs_unit</span> <span class="o">/</span> <span class="n">cgs_unit</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isscalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the `value` of this quantity is a scalar, or False if it</span>
<span class="sd">        is an array-like object.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is subtly different from `numpy.isscalar` in that</span>
<span class="sd">            `numpy.isscalar` returns False for a zero-dimensional array</span>
<span class="sd">            (e.g. ``np.array(1)``), while this is True for quantities,</span>
<span class="sd">            since quantities cannot represent true numpy scalars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># This flag controls whether convenience conversion members, such</span>
    <span class="c1"># as `q.m` equivalent to `q.to_value(u.m)` are available.  This is</span>
    <span class="c1"># not turned on on Quantity itself, but is on some subclasses of</span>
    <span class="c1"># Quantity, such as `astropy.coordinates.Angle`.</span>
    <span class="n">_include_easy_conversion_members</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quantities are able to directly convert to other units that</span>
<span class="sd">        have the same physical type.  This function is implemented in</span>
<span class="sd">        order to make autocompletion still work correctly in IPython.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_easy_conversion_members</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">()</span>

        <span class="n">dir_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">())</span>
        <span class="n">equivalencies</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">.</span><span class="n">_normalize_equivalencies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalencies</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">equivalent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_get_units_with_same_physical_type</span><span class="p">(</span><span class="n">equivalencies</span><span class="p">):</span>
            <span class="n">dir_values</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">equivalent</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dir_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quantities are able to directly convert to other units that</span>
<span class="sd">        have the same physical type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_include_easy_conversion_members</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object has no &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39; member&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_virtual_unit_attribute</span><span class="p">():</span>
            <span class="n">registry</span> <span class="o">=</span> <span class="n">get_current_unit_registry</span><span class="p">()</span><span class="o">.</span><span class="n">registry</span>
            <span class="n">to_unit</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">to_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                    <span class="n">to_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">equivalencies</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">get_virtual_unit_attribute</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> instance has no attribute &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="c1"># Equality needs to be handled explicitly as ndarray.__eq__ gives</span>
    <span class="c1"># DeprecationWarnings on any error, which is distracting, and does not</span>
    <span class="c1"># deal well with structured arrays (nor does the ufunc).</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">other_value</span><span class="p">)</span>

    <span class="c1"># Unit conversion operator (&lt;&lt;).</span>
    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parse_strict</span><span class="o">=</span><span class="s2">&quot;silent&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitTypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ilshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parse_strict</span><span class="o">=</span><span class="s2">&quot;silent&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitTypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># try other.__rlshift__(self)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_to</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitConversionError</span><span class="p">:</span>  <span class="c1"># incompatible, or requires an Equivalency</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># StructuredUnit does not have `_to`</span>
            <span class="c1"># In principle, in-place might be possible.</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">*=</span> <span class="n">factor</span>  <span class="c1"># operates on view</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># The error is `numpy.core._exceptions._UFuncOutputCastingError`,</span>
            <span class="c1"># which inherits from `TypeError`.</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">Unit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__rlshift__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># Give warning for other &gt;&gt; self, since probably other &lt;&lt; self was meant.</span>
    <span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;&gt;&gt; is not implemented. Did you mean to convert &quot;</span>
            <span class="s2">&quot;something to this quantity as a unit using &#39;&lt;&lt;&#39;?&quot;</span><span class="p">,</span>
            <span class="n">AstropyWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># Also define __rshift__ and __irshift__ so we override default ndarray</span>
    <span class="c1"># behaviour, but instead of emitting a warning here, let it be done by</span>
    <span class="c1"># other (which likely is a unit if this was a mistake).</span>
    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__irshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># Arithmetic operations</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multiplication between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># let other try to deal with it</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;In-place multiplication between `Quantity` objects and others.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__imul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Right Multiplication between `Quantity` objects and other objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># let other try to deal with it</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inplace division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__itruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Right Division between `Quantity` objects and other objects.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">UnitBase</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">):</span>
            <span class="c1"># Avoid getting object arrays by raising the value to a Fraction.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">**</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">**</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="c1"># other overrides of special functions</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object with a scalar value is not&quot;</span>
                <span class="s2">&quot; iterable&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Otherwise return a generator</span>
        <span class="k">def</span> <span class="nf">quantity_iter</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">quantity_iter</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">StructuredUnit</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)[</span><span class="n">key</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># We want zero-dimensional Quantity objects to behave like scalars,</span>
            <span class="c1"># so they should raise a TypeError rather than an IndexError.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object with a scalar value &quot;</span>
                    <span class="s2">&quot;does not support indexing&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="c1"># For single elements, ndarray.__getitem__ returns scalars; these</span>
        <span class="c1"># need a new view as a Quantity.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Indexing will cause a different unit, so by doing this in</span>
            <span class="c1"># two steps we effectively try with the right unit.</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>

        <span class="c1"># update indices in info if the info property has been accessed</span>
        <span class="c1"># (in which case &#39;info&#39; in self.__dict__ is True; this is guaranteed</span>
        <span class="c1"># to be the case if we&#39;re part of a table).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span> <span class="ow">and</span> <span class="s2">&quot;info&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">adjust_indices</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="c1"># __contains__ is OK</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Quantities should always be treated as non-False; there is too much</span>
<span class="sd">        potential for ambiguity otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The truth value of a Quantity is ambiguous. &quot;</span>
            <span class="s2">&quot;In the future this will raise a ValueError.&quot;</span><span class="p">,</span>
            <span class="n">AstropyDeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object with a scalar value has no len()&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># Numerical types</span>
    <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">UnitsError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;only dimensionless scalar quantities can be &quot;</span>
                <span class="s2">&quot;converted to Python scalars&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">UnitsError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;only dimensionless scalar quantities can be &quot;</span>
                <span class="s2">&quot;converted to Python scalars&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for indices, we do not want to mess around with scaling at all,</span>
        <span class="c1"># so unlike for float, int, we insist here on unscaled dimensionless</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_unity</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__index__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;only integer dimensionless scalar quantities &quot;</span>
                <span class="s2">&quot;can be converted to a Python index&quot;</span>
            <span class="p">)</span>

    <span class="c1"># TODO: we may want to add a hook for dimensionless quantities?</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_unitstr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="n">_UNIT_NOT_INITIALISED</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unitstr</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">unitstr</span>

        <span class="k">return</span> <span class="n">unitstr</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subfmt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a string representation of the quantity and its unit.</span>

<span class="sd">        The behavior of this function can be altered via the</span>
<span class="sd">        `numpy.set_printoptions` function and its various keywords.  The</span>
<span class="sd">        exception to this is the ``threshold`` keyword, which is controlled via</span>
<span class="sd">        the ``[units.quantity]`` configuration item ``latex_array_threshold``.</span>
<span class="sd">        This is treated separately because the numpy default of 1000 is too big</span>
<span class="sd">        for most browsers to handle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : unit-like, optional</span>
<span class="sd">            Specifies the unit.  If not provided,</span>
<span class="sd">            the unit used to initialize the quantity will be used.</span>

<span class="sd">        precision : number, optional</span>
<span class="sd">            The level of decimal precision. If `None`, or not provided,</span>
<span class="sd">            it will be determined from NumPy print options.</span>

<span class="sd">        format : str, optional</span>
<span class="sd">            The format of the result. If not provided, an unadorned</span>
<span class="sd">            string is returned. Supported values are:</span>

<span class="sd">            - &#39;latex&#39;: Return a LaTeX-formatted string</span>

<span class="sd">            - &#39;latex_inline&#39;: Return a LaTeX-formatted string that uses</span>
<span class="sd">              negative exponents instead of fractions</span>

<span class="sd">        subfmt : str, optional</span>
<span class="sd">            Subformat of the result. For the moment, only used for</span>
<span class="sd">            ``format=&#39;latex&#39;`` and ``format=&#39;latex_inline&#39;``. Supported</span>
<span class="sd">            values are:</span>

<span class="sd">            - &#39;inline&#39;: Use ``$ ... $`` as delimiters.</span>

<span class="sd">            - &#39;display&#39;: Use ``$\\displaystyle ... $`` as delimiters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A string with the contents of this Quantity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unit</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span>
                <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">subfmt</span><span class="o">=</span><span class="n">subfmt</span>
            <span class="p">)</span>

        <span class="n">formats</span> <span class="o">=</span> <span class="p">{</span>
            <span class="kc">None</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;latex&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="kc">None</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="s2">&quot;$&quot;</span><span class="p">),</span>
                <span class="s2">&quot;inline&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="s2">&quot;$&quot;</span><span class="p">),</span>
                <span class="s2">&quot;display&quot;</span><span class="p">:</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\displaystyle &quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$&quot;</span><span class="p">),</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">formats</span><span class="p">[</span><span class="s2">&quot;latex_inline&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">formats</span><span class="p">[</span><span class="s2">&quot;latex&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown format &#39;</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Use default formatting settings</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># np.array2string properly formats arrays as well as scalars</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">floatmode</span><span class="o">=</span><span class="s2">&quot;fixed&quot;</span><span class="p">)</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span>
                <span class="p">)</span>

        <span class="c1"># else, for the moment we assume format=&quot;latex&quot; or &quot;latex_inline&quot;.</span>

        <span class="c1"># Set the precision if set, otherwise use numpy default</span>
        <span class="n">pops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
        <span class="n">format_spec</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">precision</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">precision</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">pops</span><span class="p">[</span><span class="s1">&#39;precision&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">g&quot;</span>

        <span class="k">def</span> <span class="nf">float_formatter</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Latex</span><span class="o">.</span><span class="n">format_exponential_notation</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">format_spec</span><span class="o">=</span><span class="n">format_spec</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">complex_formatter</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">{}{}</span><span class="s2">i)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">Latex</span><span class="o">.</span><span class="n">format_exponential_notation</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">format_spec</span><span class="o">=</span><span class="n">format_spec</span><span class="p">),</span>
                <span class="n">Latex</span><span class="o">.</span><span class="n">format_exponential_notation</span><span class="p">(</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">format_spec</span><span class="o">=</span><span class="s2">&quot;+&quot;</span> <span class="o">+</span> <span class="n">format_spec</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># The view is needed for the scalar case - self.value might be float.</span>
        <span class="n">latex_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
            <span class="n">threshold</span><span class="o">=</span><span class="p">(</span>
                <span class="n">conf</span><span class="o">.</span><span class="n">latex_array_threshold</span>
                <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">latex_array_threshold</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span> <span class="n">pops</span><span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="n">formatter</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;float_kind&quot;</span><span class="p">:</span> <span class="n">float_formatter</span><span class="p">,</span>
                <span class="s2">&quot;complex_kind&quot;</span><span class="p">:</span> <span class="n">complex_formatter</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">max_line_width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
            <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;,~&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">latex_value</span> <span class="o">=</span> <span class="n">latex_value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\dots&quot;</span><span class="p">)</span>

        <span class="c1"># Format unit</span>
        <span class="c1"># [1:-1] strips the &#39;$&#39; on either side needed for math mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">latex_unit</span> <span class="o">=</span> <span class="n">_UNIT_NOT_INITIALISED</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;latex&quot;</span><span class="p">:</span>
            <span class="n">latex_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">_repr_latex_</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># note this is unicode</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;latex_inline&quot;</span><span class="p">:</span>
            <span class="n">latex_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;latex_inline&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">delimiter_left</span><span class="p">,</span> <span class="n">delimiter_right</span> <span class="o">=</span> <span class="n">formats</span><span class="p">[</span><span class="nb">format</span><span class="p">][</span><span class="n">subfmt</span><span class="p">]</span>

        <span class="k">return</span> <span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">delimiter_left</span><span class="si">}{</span><span class="n">latex_value</span><span class="si">}</span><span class="s2"> \; </span><span class="si">{</span><span class="n">latex_unit</span><span class="si">}{</span><span class="n">delimiter_right</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefixstr</span> <span class="o">=</span> <span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
        <span class="n">arrstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefixstr</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefixstr</span><span class="si">}{</span><span class="n">arrstr</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">_repr_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a latex representation of the quantity and its unit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lstr</span>
<span class="sd">            A LaTeX string with the contents of this Quantity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: This should change to display format in a future release</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;latex&quot;</span><span class="p">,</span> <span class="n">subfmt</span><span class="o">=</span><span class="s2">&quot;inline&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">format_spec</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># We might have a unit format not implemented in `to_string()`.</span>
            <span class="k">if</span> <span class="n">format_spec</span> <span class="ow">in</span> <span class="n">Base</span><span class="o">.</span><span class="n">registry</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="n">dimensionless_unscaled</span><span class="p">:</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span><span class="w"> </span><span class="n">format_spec</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># Can the value be formatted on its own?</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">format_spec</span><span class="p">)</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># Format the whole thing as a single string.</span>
                <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a new `Quantity` with the units</span>
<span class="sd">        decomposed. Decomposed units have only irreducible units in</span>
<span class="sd">        them (see `astropy.units.UnitBase.decompose`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bases : sequence of `~astropy.units.UnitBase`, optional</span>
<span class="sd">            The bases to decompose into.  When not provided,</span>
<span class="sd">            decomposes down to any irreducible units.  When provided,</span>
<span class="sd">            the decomposed result will only contain the given units.</span>
<span class="sd">            This will raises a `~astropy.units.UnitsError` if it&#39;s not possible</span>
<span class="sd">            to do so.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newq : `~astropy.units.Quantity`</span>
<span class="sd">            A new object equal to this quantity with units decomposed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decompose</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="n">bases</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allowscaledunits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a new `Quantity` with the units decomposed. Decomposed</span>
<span class="sd">        units have only irreducible units in them (see</span>
<span class="sd">        `astropy.units.UnitBase.decompose`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        allowscaledunits : bool</span>
<span class="sd">            If True, the resulting `Quantity` may have a scale factor</span>
<span class="sd">            associated with it.  If False, any scaling in the unit will</span>
<span class="sd">            be subsumed into the value of the resulting `Quantity`</span>

<span class="sd">        bases : sequence of UnitBase, optional</span>
<span class="sd">            The bases to decompose into.  When not provided,</span>
<span class="sd">            decomposes down to any irreducible units.  When provided,</span>
<span class="sd">            the decomposed result will only contain the given units.</span>
<span class="sd">            This will raises a `~astropy.units.UnitsError` if it&#39;s not possible</span>
<span class="sd">            to do so.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newq : `~astropy.units.Quantity`</span>
<span class="sd">            A new object equal to this quantity with units decomposed.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">bases</span><span class="o">=</span><span class="n">bases</span><span class="p">)</span>

        <span class="c1"># Be careful here because self.value usually is a view of self;</span>
        <span class="c1"># be sure that the original value is not being modified.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allowscaledunits</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_unit</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">):</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">new_unit</span><span class="o">.</span><span class="n">scale</span>
            <span class="n">new_unit</span> <span class="o">=</span> <span class="n">new_unit</span> <span class="o">/</span> <span class="n">new_unit</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">new_unit</span><span class="p">)</span>

    <span class="c1"># These functions need to be overridden to take into account the units</span>
    <span class="c1"># Array conversion</span>
    <span class="c1"># https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion</span>

    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy an element of an array to a scalar Quantity and return it.</span>

<span class="sd">        Like :meth:`~numpy.ndarray.item` except that it always</span>
<span class="sd">        returns a `Quantity`, not a Python scalar.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot make a list of Quantities. Get list of values with&quot;</span>
            <span class="s2">&quot; q.value.tolist().&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_own_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">check_precision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert value to one&#39;s own unit (or that given).</span>

<span class="sd">        Here, non-quantities are treated as dimensionless, and care is taken</span>
<span class="sd">        for values of 0, infinity or nan, which are allowed to have any unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : anything convertible to `~astropy.units.Quantity`</span>
<span class="sd">            The value to be converted to the requested unit.</span>
<span class="sd">        check_precision : bool</span>
<span class="sd">            Whether to forbit conversion of float to integer if that changes</span>
<span class="sd">            the input number.  Default: `True`.</span>
<span class="sd">        unit : `~astropy.units.Unit` or None</span>
<span class="sd">            The unit to convert to.  By default, the unit of ``self``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : number or `~numpy.ndarray`</span>
<span class="sd">            In the requested units.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># We&#39;re not a Quantity.</span>
            <span class="c1"># First remove two special cases (with a fast test):</span>
            <span class="c1"># 1) Maybe masked printing? MaskedArray with quantities does not</span>
            <span class="c1"># work very well, but no reason to break even repr and str.</span>
            <span class="c1"># 2) np.ma.masked? useful if we&#39;re a MaskedQuantity.</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">value</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_print_option</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="c1"># Now, let&#39;s try a more general conversion.</span>
            <span class="c1"># Plain arrays will be converted to dimensionless in the process,</span>
            <span class="c1"># but anything with a unit attribute will use that.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">as_quantity</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="n">as_quantity</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
                <span class="c1"># last chance: if this was not something with a unit</span>
                <span class="c1"># and is all 0, inf, or nan, we treat it as arbitrary unit.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">can_have_arbitrary_unit</span><span class="p">(</span>
                    <span class="n">as_quantity</span><span class="o">.</span><span class="n">value</span>
                <span class="p">):</span>
                    <span class="n">_value</span> <span class="o">=</span> <span class="n">as_quantity</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span> <span class="ow">and</span> <span class="n">check_precision</span><span class="p">:</span>
            <span class="c1"># If, e.g., we are casting float to int, we want to fail if</span>
            <span class="c1"># precision is lost, but let things pass if it works.</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">_value</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="n">self_dtype_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">self_dtype_array</span> <span class="o">==</span> <span class="n">_value</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">_value</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;cannot convert value type to array type without precision loss&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># Setting names to ensure things like equality work (note that</span>
        <span class="c1"># above will have failed already if units did not match).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">_value</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">return</span> <span class="n">_value</span>

    <span class="k">def</span> <span class="nf">itemset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;itemset must have at least one argument&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">itemset</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),)))</span>

    <span class="k">def</span> <span class="nf">tostring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Not implemented, use ``.value.tostring()`` instead.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot write Quantities to string.  Write array with&quot;</span>
            <span class="s2">&quot; q.value.tostring(...).&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">tobytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Not implemented, use ``.value.tobytes()`` instead.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot write Quantities to bytes.  Write array with q.value.tobytes(...).&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">tofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Not implemented, use ``.value.tofile()`` instead.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot write Quantities to file.  Write array with q.value.tofile(...)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Not implemented, use ``.value.dump()`` instead.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot dump Quantities to file.  Write array with q.value.dump()&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Not implemented, use ``.value.dumps()`` instead.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot dump Quantities to string.  Write array with q.value.dumps()&quot;</span>
        <span class="p">)</span>

    <span class="c1"># astype, byteswap, copy, view, getfield, setflags OK as is</span>

    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="c1"># Shape manipulation: resize cannot be done (does not own data), but</span>
    <span class="c1"># shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only</span>
    <span class="c1"># the flat iterator needs to be overwritten, otherwise single items are</span>
    <span class="c1"># returned as numbers.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A 1-D iterator over the Quantity array.</span>

<span class="sd">        This returns a ``QuantityIterator`` instance, which behaves the same</span>
<span class="sd">        as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,</span>
<span class="sd">        and is similar to, but not a subclass of, Python&#39;s built-in iterator</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuantityIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@flat</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># Item selection and manipulation</span>
    <span class="c1"># repeat, sort, compress, diagonal OK</span>
    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="c1"># For single elements, ndarray.take returns scalars; these</span>
        <span class="c1"># need a new view as a Quantity.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;cannot choose based on quantity.  Choose using array with&quot;</span>
            <span class="s2">&quot; q.value.choose(...)&quot;</span>
        <span class="p">)</span>

    <span class="c1"># ensure we do not return indices as quantities</span>
    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quicksort&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">check_precision</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>  <span class="c1"># avoid numpy 1.6 problem</span>

    <span class="k">if</span> <span class="n">NUMPY_LT_1_22</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_function__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap numpy functions, taking care of units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            Numpy function to wrap</span>
<span class="sd">        types : iterable of classes</span>
<span class="sd">            Classes that provide an ``__array_function__`` override. Can</span>
<span class="sd">            in principle be used to interact with other classes. Below,</span>
<span class="sd">            mostly passed on to `~numpy.ndarray`, which can only interact</span>
<span class="sd">            with subclasses.</span>
<span class="sd">        args : tuple</span>
<span class="sd">            Positional arguments provided in the function call.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Keyword arguments provided in the function call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: `~astropy.units.Quantity`, `~numpy.ndarray`</span>
<span class="sd">            As appropriate for the function.  If the function is not</span>
<span class="sd">            supported, `NotImplemented` is returned, which will lead to</span>
<span class="sd">            a `TypeError` unless another argument overrode the function.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ~astropy.units.UnitsError</span>
<span class="sd">            If operands have incompatible units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A function should be in one of the following sets or dicts:</span>
        <span class="c1"># 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation</span>
        <span class="c1">#    supports Quantity; we pass on to ndarray.__array_function__.</span>
        <span class="c1"># 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable</span>
        <span class="c1">#    after converting quantities to arrays with suitable units,</span>
        <span class="c1">#    and possibly setting units on the result.</span>
        <span class="c1"># 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but</span>
        <span class="c1">#    requires a Quantity-specific implementation.</span>
        <span class="c1"># 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.</span>
        <span class="c1"># For now, since we may not yet have complete coverage, if a</span>
        <span class="c1"># function is in none of the above, we simply call the numpy</span>
        <span class="c1"># implementation.</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">SUBCLASS_SAFE_FUNCTIONS</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_function__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">FUNCTION_HELPERS</span><span class="p">:</span>
            <span class="n">function_helper</span> <span class="o">=</span> <span class="n">FUNCTION_HELPERS</span><span class="p">[</span><span class="n">function</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">function_helper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_not_implemented_or_raise</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_function__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Fall through to return section</span>

        <span class="k">elif</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">DISPATCHED_FUNCTIONS</span><span class="p">:</span>
            <span class="n">dispatched_function</span> <span class="o">=</span> <span class="n">DISPATCHED_FUNCTIONS</span><span class="p">[</span><span class="n">function</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">dispatched_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_not_implemented_or_raise</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>

            <span class="c1"># Fall through to return section</span>

        <span class="k">elif</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">UNSUPPORTED_FUNCTIONS</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;function &#39;</span><span class="si">{</span><span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; is not known to astropy&#39;s Quantity.&quot;</span>
                <span class="s2">&quot; Will run it anyway, hoping it will treat ndarray subclasses&quot;</span>
                <span class="s2">&quot; correctly. Please raise an issue at&quot;</span>
                <span class="s2">&quot; https://github.com/astropy/astropy/issues.&quot;</span><span class="p">,</span>
                <span class="n">AstropyWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_function__</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If unit is None, a plain array is expected (e.g., boolean), which</span>
        <span class="c1"># means we&#39;re done.</span>
        <span class="c1"># We&#39;re also done if the result was NotImplemented, which can happen</span>
        <span class="c1"># if other inputs/outputs override __array_function__;</span>
        <span class="c1"># hopefully, they can then deal with us.</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_not_implemented_or_raise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="c1"># Our function helper or dispatcher found that the function does not</span>
        <span class="c1"># work with Quantity.  In principle, there may be another class that</span>
        <span class="c1"># knows what to do with us, for which we should return NotImplemented.</span>
        <span class="c1"># But if there is ndarray (or a non-Quantity subclass of it) around,</span>
        <span class="c1"># it quite likely coerces, so we should just break.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;the Quantity implementation cannot handle </span><span class="si">{</span><span class="n">function</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;with the given arguments.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># Calculation -- override ndarray methods to take into account units.</span>
    <span class="c1"># We use the corresponding numpy functions to evaluate the results, since</span>
    <span class="c1"># the methods do not always allow calling with keyword arguments.</span>
    <span class="c1"># For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives</span>
    <span class="c1"># TypeError: &#39;a_max&#39; is an invalid keyword argument for this function.</span>
    <span class="k">def</span> <span class="nf">_wrap_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap a numpy function that processes self, returning a Quantity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            Numpy function to wrap.</span>
<span class="sd">        args : positional arguments</span>
<span class="sd">            Any positional arguments to the function beyond the first argument</span>
<span class="sd">            (which will be set to ``self``).</span>
<span class="sd">        kwargs : keyword arguments</span>
<span class="sd">            Keyword arguments to the function.</span>

<span class="sd">        If present, the following arguments are treated specially:</span>

<span class="sd">        unit : `~astropy.units.Unit`</span>
<span class="sd">            Unit of the output result.  If not given, the unit of ``self``.</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            A Quantity instance in which to store the output.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Output should always be assigned via a keyword argument, otherwise</span>
<span class="sd">        no proper account of the unit is taken.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            Result of the function call, with the unit set properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
        <span class="c1"># Ensure we don&#39;t loop back by turning any Quantity into array views.</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If pre-allocated output is used, check it is suitable.</span>
            <span class="c1"># This also returns array view, to ensure we don&#39;t loop back.</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check_output</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
        <span class="c1"># Apply the function and turn it back into a Quantity.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_as_quantity</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">result_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">*</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">dimensionless_unscaled</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">result_unit</span><span class="p">)</span>

    <span class="c1"># Calculation: override methods that do not make sense.</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;cannot evaluate truth value of quantities. &quot;</span>
            <span class="s2">&quot;Evaluate array with q.value.all(...)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;cannot evaluate truth value of quantities. &quot;</span>
            <span class="s2">&quot;Evaluate array with q.value.any(...)&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Calculation: numpy functions that can be overridden with methods.</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ediff1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">,</span> <span class="n">to_end</span><span class="p">,</span> <span class="n">to_begin</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">NUMPY_LT_1_22</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO: deprecate this method? It is not on ndarray, and we do not</span>
        <span class="c1"># support nanmean, etc., so why this one?</span>
        <span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_function</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">,</span>
                <span class="n">axis</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span>
                <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert values along the given axis before the given indices and return</span>
<span class="sd">        a new `~astropy.units.Quantity` object.</span>

<span class="sd">        This is a thin wrapper around the `numpy.insert` function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : int, slice or sequence of int</span>
<span class="sd">            Object that defines the index or indices before which ``values`` is</span>
<span class="sd">            inserted.</span>
<span class="sd">        values : array-like</span>
<span class="sd">            Values to insert.  If the type of ``values`` is different</span>
<span class="sd">            from that of quantity, ``values`` is converted to the matching type.</span>
<span class="sd">            ``values`` should be shaped so that it can be broadcast appropriately</span>
<span class="sd">            The unit of ``values`` must be consistent with this quantity.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to insert ``values``.  If ``axis`` is None then</span>
<span class="sd">            the quantity array is flattened before insertion.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~astropy.units.Quantity`</span>
<span class="sd">            A copy of quantity with ``values`` inserted.  Note that the</span>
<span class="sd">            insertion does not occur in-place: a new quantity array is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">        &gt;&gt;&gt; q = [1, 2] * u.m</span>
<span class="sd">        &gt;&gt;&gt; q.insert(0, 50 * u.cm)</span>
<span class="sd">        &lt;Quantity [ 0.5,  1.,  2.] m&gt;</span>

<span class="sd">        &gt;&gt;&gt; q = [[1, 2], [3, 4]] * u.m</span>
<span class="sd">        &gt;&gt;&gt; q.insert(1, [10, 20] * u.m, axis=0)</span>
<span class="sd">        &lt;Quantity [[  1.,  2.],</span>
<span class="sd">                   [ 10., 20.],</span>
<span class="sd">                   [  3.,  4.]] m&gt;</span>

<span class="sd">        &gt;&gt;&gt; q.insert(1, 10 * u.m, axis=1)</span>
<span class="sd">        &lt;Quantity [[  1., 10.,  2.],</span>
<span class="sd">                   [  3., 10.,  4.]] m&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_own_unit</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_view</span><span class="p">(</span><span class="n">out_array</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SpecificTypeQuantity</span><span class="p">(</span><span class="n">Quantity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Superclass for Quantities of specific physical type.</span>

<span class="sd">    Subclasses of these work just like :class:`~astropy.units.Quantity`, except</span>
<span class="sd">    that they are for specific physical types (and may have methods that are</span>
<span class="sd">    only appropriate for that type).  Astropy examples are</span>
<span class="sd">    :class:`~astropy.coordinates.Angle` and</span>
<span class="sd">    :class:`~astropy.coordinates.Distance`</span>

<span class="sd">    At a minimum, subclasses should set ``_equivalent_unit`` to the unit</span>
<span class="sd">    associated with the physical type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># The unit for the specific physical type.  Instances can only be created</span>
    <span class="c1"># with units that are equivalent to this.</span>
    <span class="n">_equivalent_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># The default unit used for views.  Even with `None`, views of arrays</span>
    <span class="c1"># without units are possible, but will have an uninitialized unit.</span>
    <span class="n">_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Default unit for initialization through the constructor.</span>
    <span class="n">_default_unit</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ensure that we get precedence over our superclass.</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="n">Quantity</span><span class="o">.</span><span class="n">__array_priority__</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="k">def</span> <span class="nf">__quantity_subclass__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__quantity_subclass__</span><span class="p">(</span><span class="n">unit</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnitTypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> instances require units equivalent to &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equivalent_unit</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span>
                    <span class="s2">&quot;, but no unit was given.&quot;</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;, so cannot set it to &#39;</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a boolean array where two arrays are element-wise equal</span>
<span class="sd">    within a tolerance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array-like or `~astropy.units.Quantity`</span>
<span class="sd">        Input values or arrays to compare</span>
<span class="sd">    rtol : array-like or `~astropy.units.Quantity`</span>
<span class="sd">        The relative tolerance for the comparison, which defaults to</span>
<span class="sd">        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,</span>
<span class="sd">        then it must be dimensionless.</span>
<span class="sd">    atol : number or `~astropy.units.Quantity`</span>
<span class="sd">        The absolute tolerance for the comparison.  The units (or lack</span>
<span class="sd">        thereof) of ``a``, ``b``, and ``atol`` must be consistent with</span>
<span class="sd">        each other.  If `None`, ``atol`` defaults to zero in the</span>
<span class="sd">        appropriate units.</span>
<span class="sd">    equal_nan : `bool`</span>
<span class="sd">        Whether to compare NaNs as equal. If `True`, NaNs in ``a`` will</span>
<span class="sd">        be considered equal to NaNs in ``b``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a :class:`~astropy.units.Quantity`-aware version of</span>
<span class="sd">    :func:`numpy.isclose`. However, this differs from the `numpy` function in</span>
<span class="sd">    that the default for the absolute tolerance here is zero instead of</span>
<span class="sd">    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default</span>
<span class="sd">    *absolute* tolerance given two inputs that may have differently scaled</span>
<span class="sd">    units.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    `~astropy.units.UnitsError`</span>
<span class="sd">        If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,</span>
<span class="sd">        or if ``rtol`` is not dimensionless.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    allclose</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unquantified_args</span> <span class="o">=</span> <span class="n">_unquantify_allclose_arguments</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="o">*</span><span class="n">unquantified_args</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1.0e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Whether two arrays are element-wise equal within a tolerance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array-like or `~astropy.units.Quantity`</span>
<span class="sd">        Input values or arrays to compare</span>
<span class="sd">    rtol : array-like or `~astropy.units.Quantity`</span>
<span class="sd">        The relative tolerance for the comparison, which defaults to</span>
<span class="sd">        ``1e-5``.  If ``rtol`` is a :class:`~astropy.units.Quantity`,</span>
<span class="sd">        then it must be dimensionless.</span>
<span class="sd">    atol : number or `~astropy.units.Quantity`</span>
<span class="sd">        The absolute tolerance for the comparison.  The units (or lack</span>
<span class="sd">        thereof) of ``a``, ``b``, and ``atol`` must be consistent with</span>
<span class="sd">        each other.  If `None`, ``atol`` defaults to zero in the</span>
<span class="sd">        appropriate units.</span>
<span class="sd">    equal_nan : `bool`</span>
<span class="sd">        Whether to compare NaNs as equal. If `True`, NaNs in ``a`` will</span>
<span class="sd">        be considered equal to NaNs in ``b``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a :class:`~astropy.units.Quantity`-aware version of</span>
<span class="sd">    :func:`numpy.allclose`. However, this differs from the `numpy` function in</span>
<span class="sd">    that the default for the absolute tolerance here is zero instead of</span>
<span class="sd">    ``atol=1e-8`` in `numpy`, as there is no natural way to set a default</span>
<span class="sd">    *absolute* tolerance given two inputs that may have differently scaled</span>
<span class="sd">    units.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    `~astropy.units.UnitsError`</span>
<span class="sd">        If the dimensions of ``a``, ``b``, or ``atol`` are incompatible,</span>
<span class="sd">        or if ``rtol`` is not dimensionless.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    isclose</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unquantified_args</span> <span class="o">=</span> <span class="n">_unquantify_allclose_arguments</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="o">*</span><span class="n">unquantified_args</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unquantify_allclose_arguments</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">desired</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">):</span>
    <span class="n">actual</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">desired</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">desired</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">desired</span> <span class="o">=</span> <span class="n">desired</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">actual</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Units for &#39;desired&#39; (</span><span class="si">{</span><span class="n">desired</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">) and &#39;actual&#39; &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">actual</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">) are not convertible&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">atol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># By default, we assume an absolute tolerance of zero in the</span>
        <span class="c1"># appropriate units.  The default value of None for atol is</span>
        <span class="c1"># needed because the units of atol must be consistent with the</span>
        <span class="c1"># units for a and b.</span>
        <span class="n">atol</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">atol</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">actual</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">UnitsError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Units for &#39;atol&#39; (</span><span class="si">{</span><span class="n">atol</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">) and &#39;actual&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">actual</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">) are not convertible&quot;</span>
            <span class="p">)</span>

    <span class="n">rtol</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;&#39;rtol&#39; should be dimensionless&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">actual</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">desired</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">rtol</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">atol</span><span class="o">.</span><span class="n">value</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright ctapipe developers.  Last updated 09 Feb 2023 14:43.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>